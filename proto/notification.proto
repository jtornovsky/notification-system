syntax = "proto3";

package notification;

// This will be the Go package path when we generate Go code from this proto file.
option go_package = "github.com/jtornovsky/notification-system/proto";

// ============================================================================
// MAIN NOTIFICATION MESSAGE
// ============================================================================
// This is the primary data structure that flows through our entire system.
// When a user creates a notification via the API, this message gets:
// 1. Created by api-gateway
// 2. Published to Kafka topic "notifications"
// 3. Consumed by notification-processor
// 4. Processed and republished to type-specific topics (email-notifications, sms-notifications, etc.)
// 5. Consumed by delivery-service for actual sending
message Notification {
  string id = 1;                    // Unique identifier (UUID), generated by api-gateway
  string user_id = 2;               // Who created this notification (for tracking/permissions)
  NotificationType type = 3;        // What kind of notification: EMAIL, SMS, or PUSH
  string recipient = 4;             // Where to send: email address, phone number, or device token
  string subject = 5;               // Subject line (mainly for emails, can be empty for SMS/PUSH)
  string message = 6;               // The actual notification content/body
  int64 created_at = 7;             // Unix timestamp (milliseconds) when notification was created
  NotificationStatus status = 8;    // Current state in the processing pipeline
  map<string, string> metadata = 9; // Flexible key-value pairs for additional data
                                    // Examples: {"priority": "high", "campaign_id": "summer2024"}
}

// ============================================================================
// NOTIFICATION TYPE ENUM
// ============================================================================
// Defines the delivery channels we support.
// In a real system, each type might have different:
// - Rate limits (SMS is expensive, email is cheap)
// - Formatting requirements (SMS has 160 char limit)
// - Delivery guarantees (PUSH needs device to be online)
enum NotificationType {
  EMAIL = 0;  // Standard email notification
  SMS = 1;    // Text message (usually costs money per message)
  PUSH = 2;   // Mobile push notification (requires device token)
}

// ============================================================================
// NOTIFICATION STATUS ENUM
// ============================================================================
// Tracks the notification's journey through our microservices.
// Status changes are important for:
// - User dashboards (showing real-time progress)
// - Analytics (measuring success rates)
// - Debugging (where did it fail?)
// - Retries (only retry FAILED, not DELIVERED)
enum NotificationStatus {
  PENDING = 0;     // Just created, waiting to be picked up by processor
  PROCESSING = 1;  // notification-processor is working on it (validation, routing)
  SENT = 2;        // delivery-service attempted to send it (but may not be delivered yet)
  FAILED = 3;      // Something went wrong (invalid recipient, service down, etc.)
  DELIVERED = 4;   // Successfully delivered and confirmed (final success state)
}

// ============================================================================
// DELIVERY EVENT MESSAGE
// ============================================================================
// This is published by delivery-service AFTER it attempts to send a notification.
// It flows to analytics-service via Kafka topic "delivery-events"
// 
// Purpose:
// - Track success/failure rates
// - Measure performance (delivery_time_ms)
// - Build analytics dashboards
// - Trigger alerts if error rates spike
// - Update Elasticsearch for searching/reporting
message DeliveryEvent {
  string notification_id = 1;       // References the original Notification.id
  NotificationStatus status = 2;    // Result: SENT, FAILED, or DELIVERED
  int64 processed_at = 3;           // Unix timestamp when delivery was attempted
  string error_message = 4;         // If FAILED, what went wrong? (e.g., "Invalid email address")
  int32 delivery_time_ms = 5;       // How long did the delivery attempt take? (for performance metrics)
}

// ============================================================================
// HOW THESE MESSAGES FLOW THROUGH THE SYSTEM
// ============================================================================
// 
// 1. User submits via React dashboard â†’ api-gateway creates Notification
// 2. api-gateway publishes Notification to Kafka topic "notifications"
// 3. notification-processor consumes from "notifications", validates, republishes to "email-notifications"
// 4. delivery-service consumes from "email-notifications", simulates sending
// 5. delivery-service publishes DeliveryEvent to "delivery-events" topic
// 6. analytics-service consumes DeliveryEvent, indexes to Elasticsearch
// 7. React dashboard queries api-gateway which reads from MongoDB and Elasticsearch
//
// Why Protobuf instead of JSON?
// - Type safety: Can't accidentally send wrong field types
// - Performance: Smaller message size (important for high-volume Kafka)
// - Code generation: Auto-generate Go and Node.js code from this single definition
// - Versioning: Can safely add new fields without breaking old consumers (forward/backward compatibility)